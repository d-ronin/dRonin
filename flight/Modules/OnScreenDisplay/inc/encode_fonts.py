#!/usr/bin/env python3

"""
**
 ******************************************************************************
 * @file       encode_fonts.py
 * @author     dRonin, http://dRonin.org/, Copyright (C) 2016
 * @addtogroup dRonin Modules
 * @{
 * @addtogroup OnScreenDisplay Module
 * @{
 * @brief Font converter script for OSD
 *****************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, see <http://www.gnu.org/licenses/>
 *
 * Additional note on redistribution: The copyright and license notices above
 * must be maintained in each individual source file that is a derivative work
 * of this source file; otherwise redistribution is prohibited.
 """


import os.path as op

from string import Template
from itertools import chain, repeat

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg 

file_header = Template("""
/**
 ******************************************************************************
 * @file       $FILENAME
 * @author     dRonin, http://dRonin.org/, Copyright (C) 2016
 * @author     The OpenPilot Team, http://www.openpilot.org, Copyright (C) 2012
 * @author     Thomas Oldbury Copyright (C) 2010
 * @addtogroup dRonin Modules
 * @{
 * @addtogroup OnScreenDisplay Module
 * @{
 * @brief Fonts for OSD
 *****************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, see <http://www.gnu.org/licenses/>
 *
 * Additional note on redistribution: The copyright and license notices above
 * must be maintained in each individual source file that is a derivative work
 * of this source file; otherwise redistribution is prohibited.
 *
 * NOTE: This file is generated by encode_fonts.py DO NOT EDIT!
 * NOTE: Some fonts are CC 3.0 BY-SA and note GPL licensed. See FONT_LICENSE.txt
 */


""")


font_header_template = Template("""
#ifndef FONTS_H
#define FONTS_H

#include <openpilot.h>


struct FontEntry {
\tuint8_t width;
\tuint8_t height;
\tconst uint8_t* lookup;
\tconst uint16_t* data;
};

#define NUM_FONTS  $NUM_FONTS

$names

#endif /* FONTS_H */
""")

font_c_template = Template("""
static const struct FontEntry font_$name = {
\t.width = $width,
\t.height = $height,
\t.lookup = lookup_$name,
\t.data = (uint16_t*)data_$name
};

""")


font_c_table = Template("""
const struct FontEntry* fonts[NUM_FONTS] = {$CONTENT};

""")

def grouper(n, iterable, padvalue=None):
    "grouper(3, 'abcdefg', 'x') --> ('a','b','c'), ('d','e','f'), ('g','x','x')"
    return zip(*[chain(iterable, repeat(padvalue, n-1))]*n)


def encode_font(fname, start, last):
    img = img=mpimg.imread(fname)
    height, width, depth = img.shape
    font_height = int(height / 16)
    font_width = int(width / 16)
    if font_width * 16 != width or font_height * 16 != height:
        raise RuntimeError("width or height of image is not divisable by 16!")
    gray = np.max(img[:, :, :3], axis=-1)
    bw = gray > 0.9

    if depth == 4:
        alpha = img[:, :, -1]
        mask = alpha > 0.5
    elif depth == 3:
        mask = np.logical_or(gray < 0.1, gray > 0.9)

    # determine which chraracters are present, ceate lookup table
    pos = 0
    lookup = np.zeros(256, dtype=np.uint8)
    lookup.fill(255)
    for ii in range(start, last + 1):
        row = int(ii / 16) * font_height
        col = (ii % 16) * font_width
        if np.sum(mask[row:row + font_height, col:col + font_width]) > 0:
            lookup[ii] = pos
            pos += 1
    n_active = pos + 1
    print('Encoding %s: %d x %d pixels / character. Active characters: %d' % (fname, font_width, font_height, n_active))

    out_height = n_active * font_height
    # width in bytes
    byte_width_split = int(np.ceil(font_width / float(8)))
    # buffers for OSDs with split level/mask buffers
    mask_buffer = np.zeros((out_height, byte_width_split), dtype=np.uint8)
    level_buffer = np.zeros((out_height, byte_width_split), dtype=np.uint8)
    # buffer for OSDs with a single buffer
    byte_width = int(np.ceil(font_width / float(4)))
    data_buffer = np.zeros((out_height, byte_width), dtype=np.uint8)

    row_out = 0
    for ii, entry in enumerate(lookup):
        if entry == 255:
            continue
        for row in range(0, font_height):
            row_in = int(ii / 16) * font_height + row
            for col in range(font_width):
                col_in = (ii % 16) * font_width + col
                if mask[row_in, col_in]:
                    pos = int(col / 8)
                    mask_buffer[row_out, pos] |= 0x01 << (7 - (col % 8))
                    level_buffer[row_out, pos] |= ~bw[row_in, col_in] << (7 - (col % 8))
                    pos = int(col / 4)
                    data_buffer[row_out, pos] |= (bw[row_in, col_in] << (7 - 2 * (col % 4))) | (0x01 << (6 - 2 * (col % 4)))
            row_out += 1
    
    if data_buffer.shape[1] == 3:
        data_buffer = np.c_[data_buffer, np.zeros((out_height, 1), dtype=np.uint8)]

    data_split_buffer = np.c_[level_buffer, mask_buffer]

    font = dict(width=font_width, height=font_height,
                data=data_buffer, data_split=data_split_buffer, lookup=lookup)
    return font


def c_format_font(fid, name, font, buffer_names, buffers, row_width=16):
    """Format image as a C header"""
    for buf_name, buf in zip(buffer_names, buffers):
        if len(font[buf].shape) == 1 or font[buf].shape[1] == 1:
            word_size = 8
        elif font[buf].shape[1] == 2:
            word_size = 16
        else:
            word_size = 32
        fid.write('const uint%d_t %s_%s[] = {\n' % (word_size, buf_name, name))

        n_rows = np.ceil(len(font[buf].ravel()) / float(row_width))
        for ii, row in enumerate(grouper(row_width, font[buf].ravel())):
            row = [val for val in row if val is not None]
            fid.write('\t')

            if word_size == 8:
                for byte in row:
                    fid.write('0x%0.2X, ' % byte)
            elif word_size == 16:
                for pos in range(int(len(row) / 2)):
                    fid.write('0x%0.2X%0.2X, ' % (row[2 * pos], row[2 * pos + 1]))
            elif word_size == 32:
                    for pos in range(int(len(row) / 4)):
                        value = (row[4 * pos], row[4 * pos + 1], row[4 * pos + 2], row[4 * pos + 3])
                        fid.write('0x%0.2X%0.2X%0.2X%0.2X, ' % value)
            if ii < n_rows - 1:
                fid.write('\n')
            else:
                fid.write('};\n\n')


if __name__ == '__main__':
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option('-o', '--out', dest='filename_out',
                      help='Output file', metavar='FILE')
    parser.add_option('-d', '--header', dest='filename_header_out',
                      help='Output header file', metavar='FILE')
    parser.add_option('-s', '--start', dest='start',
                      help='First ASCII character to encode',
                      type="int", default=0)
    parser.add_option('-l', '--last', dest='last',
                      help='Last ASCII character to encode',
                      type="int", default=255)

    options, args = parser.parse_args()

    in_files = args
    names = [fname[:-4] for fname in in_files]
    print('Input fonts: %s' % str(in_files))
    fonts = dict()
    for name,fname in zip(names, in_files):
        fonts[name] = encode_font(fname, options.start, options.last)

    n_fonts = len(fonts)
    with open(options.filename_header_out, 'w') as fid:
        font_name_str = ''
        for ii, name in enumerate(names):
            font_name_str += '#define %s %d\n' % (name.upper(), ii)
        fid.write(file_header.substitute(FILENAME=op.basename(options.filename_header_out)))
        fid.write(font_header_template.substitute(NUM_FONTS=n_fonts, names=font_name_str))


    with open(options.filename_out, 'w') as fid:
        fid.write(file_header.substitute(FILENAME=op.basename(options.filename_header_out)))
        fid.write('#include "fonts.h"\n')
        fid.write('#if defined(PIOS_VIDEO_SPLITBUFFER)\n')
        for name in names:
            font = fonts[name]
            c_format_font(fid, name, font, buffer_names=('data',), buffers=('data_split',))
        fid.write('#else /* defined(PIOS_VIDEO_SPLITBUFFER) */\n')
        for name in names:
            font = fonts[name]
            c_format_font(fid, name, font, buffer_names=('data',), buffers=('data',))
        fid.write('#endif /* defined(PIOS_VIDEO_SPLITBUFFER) */\n')
        for name in names:
            font = fonts[name]
            c_format_font(fid, name, font, buffer_names=('lookup',), buffers=('lookup',))

        for name in names:
            font = fonts[name]
            fid.write(font_c_template.substitute(width=font['width'],
                                                 height=font['height'], name=name))
        # write the font table
        content = ''
        for name in names:
            content += '&font_' + name + ', '
        content = content[:-2]
        fid.write(font_c_table.substitute(CONTENT=content))
